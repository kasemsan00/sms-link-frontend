import { useState, useEffect, useRef, useLayoutEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { initialConstraints } from "./function";
import ControlVideo from "../VideoCall/ControlVideo";
import StatusBarVideo from "../Status/StatusBarVideo";
import VideoContent from "./VideoContent";
import ChatVideo from "../ChatVideo";
import { setWebStatus, resetWebStatus } from "../../redux/slices/webStatusSlice";
import { setUserActiveStatus } from "../../redux/slices/userActiveStatusSlice";
import { resetSip, setSession } from "../../redux/slices/sipSlice";
import { ConvertToRTTEvent } from "../Utilities/ConvertToRTTEvent";
import { DisplayBuffer } from "../ChatPage/realtime-text";
import { addMessageData } from "../../redux/slices/messageDataSlice";
import { setControlVideo } from "../../redux/slices/controlVideoSlice";
import { setCallNumber } from "../../redux/slices/linkDetailSlice";
import adapter from "webrtc-adapter";
import useUserAgentCall from "../../hooks/useUserAgentCall";

let localStream = null;
let peerConnection = null;

let constraints = initialConstraints();

export default function VideoCall() {
    const localVideoRef = useRef(null);
    const remoteVideoRef = useRef(null);
    const dispatch = useDispatch();

    const { userAgent } = useSelector((state) => state.sip);
    const controlVideo = useSelector((state) => state.controlVideo);
    const webStatus = useSelector((state) => state.webStatus);
    const stream = useSelector((state) => state.stream);
    const { domain } = useSelector((state) => state.linkDetail);
    const [setStartCall] = useUserAgentCall({ localVideoRef, remoteVideoRef });

    const [realtimeText, setRealtimeText] = useState("");
    const [connection, setConnection] = useState(false);

    useEffect(() => {
        setStartCall(true);
    }, [setStartCall]);

    // useEffect(() => {
    //     if (startCall !== null) {
    //         console.log("init", startCall);
    //         setStartCall(true);
    //     }
    //     if (startCall === true) {
    //         console.log("ua call");
    //     }
    //     return () => {
    //         setStartCall(false);
    //     };
    // }, [stream, startCall]);

    // useEffect(() => {
    //     const display = new DisplayBuffer((resp) => {
    //         if (resp.drained === true) {
    //             setRealtimeText(resp.text);
    //         }
    //     });
    //     if (!localVideoRef) {
    //         return;
    //     }
    //     if (localStream !== null) {
    //         return;
    //     }
    //     console.log("init camera");
    //     navigator.mediaDevices
    //         .getUserMedia(constraints)
    //         .then((stream) => {
    //             if (localStream === null) {
    //                 localStream = stream;
    //                 const eventHandlers = {
    //                     peerconnection: (pc) => {
    //                         peerConnection = pc;
    //                     },
    //                 };
    //                 const options = {
    //                     eventHandlers: eventHandlers,
    //                     mediaStream: stream,
    //                     pcConfig: [
    //                         {
    //                             urls: process.env.NEXT_PUBLIC_TURN_DOMAIN,
    //                             username: process.env.NEXT_PUBLIC_TURN_USERNAME,
    //                             credential: process.env.NEXT_PUBLIC_TURN_CREDENTIAL,
    //                         },
    //                     ],
    //                     sessionTimersExpires: 9999,
    //                 };
    //                 userAgent.on("newMessage", async (event) => {
    //                     const messageBody = event.message._request.body;
    //                     if (messageBody.startsWith("@MCU")) {
    //                         setTimeout(() => {
    //                             localVideoRef.current.srcObject.getTracks().forEach(function (track) {
    //                                 if (track.kind === "video") track.enabled = false;
    //                             });
    //                         }, 4000);
    //                         setTimeout(() => {
    //                             localVideoRef.current.srcObject.getTracks().forEach(function (track) {
    //                                 if (track.kind === "video") track.enabled = true;
    //                             });
    //                             dispatch(setControlVideo("typeAsteriskCall", "MCU"));
    //                             setConnection(true);
    //                         }, 5000);
    //                         return null;
    //                     }
    //                     if (messageBody.startsWith("@switch")) {
    //                         dispatch(setCallNumber({ agent: event.message._request.body.split("|")[1] }));
    //                         return null;
    //                     }
    //                     if (messageBody !== "" && !messageBody.startsWith("<rtt")) {
    //                         display.commit();
    //                         setRealtimeText("");
    //                         dispatch(addMessageData({ type: "remote", body: messageBody, date: "" }));
    //                         return null;
    //                     }
    //                     const rttEvent = await ConvertToRTTEvent(messageBody);
    //                     display.process(rttEvent);
    //                 });
    //                 userAgent.on("newRTCSession", (ev1) => {
    //                     let newSession = ev1.session;
    //                     dispatch(setSession(newSession));

    //                     if (ev1.originator === "local") {
    //                         newSession.connection.addEventListener("addstream", (event) => {
    //                             dispatch(setUserActiveStatus("close"));
    //                             setConnection(true);
    //                             remoteVideoRef.current.srcObject = event.stream;
    //                         });
    //                     }
    //                     newSession.on("connecting", dispatch(setUserActiveStatus("close")));
    //                     newSession.on("ended", dispatch(setWebStatus("ended")));
    //                     newSession.on("failed", () => {
    //                         dispatch(setWebStatus(""));
    //                         localVideoRef.current.srcObject.getTracks()?.forEach((track) => track.stop());
    //                         remoteVideoRef.current.srcObject.getTracks()?.forEach((track) => track.stop());
    //                     });
    //                 });
    //                 localStream = stream;
    //                 localVideoRef.current.srcObject = stream;

    //                 console.log("Sip Call");
    //                 // sip.userAgent.call("sip:" + agent + "@" + domain, options);
    //                 userAgent.call("sip:9999@" + domain, options);
    //             } else {
    //                 stream.getTracks()?.forEach((track) => {
    //                     track.stop();
    //                 });
    //                 localStream = null;
    //             }
    //         })
    //         .catch((err) => {
    //             console.log(err);
    //             alert("Please allow camera");
    //             dispatch(resetWebStatus());
    //             dispatch(resetSip());
    //         });
    // }, [webStatus, localVideoRef]);

    useLayoutEffect(() => {
        if (remoteVideoRef !== null) {
            remoteVideoRef.current.muted = controlVideo.openAudio;
        }
    }, [controlVideo.openAudio, remoteVideoRef]);

    useEffect(() => {
        if (controlVideo.facingMode !== "") {
            localVideoRef.current.srcObject.getTracks().forEach(function (track) {
                track.stop();
            });

            constraints.video.facingMode.exact = controlVideo.facingMode;
            console.log(constraints);

            navigator.mediaDevices
                .getUserMedia(constraints)
                .then((stream) => {
                    localVideoRef.current.srcObject = stream;
                    peerConnection.peerconnection.getSenders().map(function (sender) {
                        sender.replaceTrack(
                            stream.getTracks().find(function (track) {
                                return track.kind === sender.track.kind;
                            }),
                        );
                    });
                })
                .catch((e) => console.error(e));
        }
    }, [controlVideo.facingMode, connection, userAgent]);

    return (
        <>
            <StatusBarVideo show={true} start={connection} />
            <VideoContent localVideoRef={localVideoRef} remoteVideoRef={remoteVideoRef} />
            <ChatVideo realtimeText={realtimeText} />
            <ControlVideo />
        </>
    );
}
